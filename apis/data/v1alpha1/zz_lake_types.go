/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AwsObservation struct {
	ExternalID *string `json:"externalId,omitempty" tf:"external_id,omitempty"`

	IAMAssumedRoleArn *string `json:"iamAssumedRoleArn,omitempty" tf:"iam_assumed_role_arn,omitempty"`

	IAMUserArn *string `json:"iamUserArn,omitempty" tf:"iam_user_arn,omitempty"`
}

type AwsParameters struct {

	// +kubebuilder:validation:Required
	RoleID *string `json:"roleId" tf:"role_id,omitempty"`

	// +kubebuilder:validation:Required
	TestS3Bucket *string `json:"testS3Bucket" tf:"test_s3_bucket,omitempty"`
}

type CollectionsObservation struct {
}

type CollectionsParameters struct {

	// +kubebuilder:validation:Required
	DataSources []DataSourcesParameters `json:"dataSources" tf:"data_sources,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type DataProcessRegionObservation struct {
}

type DataProcessRegionParameters struct {

	// +kubebuilder:validation:Required
	CloudProvider *string `json:"cloudProvider" tf:"cloud_provider,omitempty"`

	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`
}

type DataSourcesObservation struct {
}

type DataSourcesParameters struct {

	// +kubebuilder:validation:Required
	DefaultFormat *string `json:"defaultFormat" tf:"default_format,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +kubebuilder:validation:Required
	StoreName *string `json:"storeName" tf:"store_name,omitempty"`
}

type LakeObservation struct {
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	StorageDatabases []StorageDatabasesObservation `json:"storageDatabases,omitempty" tf:"storage_databases,omitempty"`

	StorageStores []StorageStoresObservation `json:"storageStores,omitempty" tf:"storage_stores,omitempty"`
}

type LakeParameters struct {

	// +kubebuilder:validation:Required
	Aws []AwsParameters `json:"aws" tf:"aws,omitempty"`

	// +kubebuilder:validation:Optional
	DataProcessRegion []DataProcessRegionParameters `json:"dataProcessRegion,omitempty" tf:"data_process_region,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`
}

type StorageDatabasesObservation struct {
}

type StorageDatabasesParameters struct {

	// +kubebuilder:validation:Required
	Collections []CollectionsParameters `json:"collections" tf:"collections,omitempty"`

	// +kubebuilder:validation:Required
	MaxWildcardCollections *float64 `json:"maxWildcardCollections" tf:"max_wildcard_collections,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Views []ViewsParameters `json:"views" tf:"views,omitempty"`
}

type StorageStoresObservation struct {
}

type StorageStoresParameters struct {

	// +kubebuilder:validation:Required
	AdditionalStorageClasses []*string `json:"additionalStorageClasses" tf:"additional_storage_classes,omitempty"`

	// +kubebuilder:validation:Required
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// +kubebuilder:validation:Required
	Delimiter *string `json:"delimiter" tf:"delimiter,omitempty"`

	// +kubebuilder:validation:Required
	IncludeTags *bool `json:"includeTags" tf:"include_tags,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Required
	Provider *string `json:"provider" tf:"provider,omitempty"`

	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`
}

type ViewsObservation struct {
}

type ViewsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Pipeline *string `json:"pipeline" tf:"pipeline,omitempty"`

	// +kubebuilder:validation:Required
	Source *string `json:"source" tf:"source,omitempty"`
}

// LakeSpec defines the desired state of Lake
type LakeSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LakeParameters `json:"forProvider"`
}

// LakeStatus defines the observed state of Lake.
type LakeStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LakeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Lake is the Schema for the Lakes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,mongodbajet}
type Lake struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LakeSpec   `json:"spec"`
	Status            LakeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LakeList contains a list of Lakes
type LakeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Lake `json:"items"`
}

// Repository type metadata.
var (
	Lake_Kind             = "Lake"
	Lake_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Lake_Kind}.String()
	Lake_KindAPIVersion   = Lake_Kind + "." + CRDGroupVersion.String()
	Lake_GroupVersionKind = CRDGroupVersion.WithKind(Lake_Kind)
)

func init() {
	SchemeBuilder.Register(&Lake{}, &LakeList{})
}
